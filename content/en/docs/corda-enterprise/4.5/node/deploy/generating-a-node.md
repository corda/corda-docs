---
date: '2020-04-07T12:00:00Z'
menu:
  corda-enterprise-4-5:
    parent: corda-enterprise-4-5-corda-nodes-deploying
tags:
- generating
- node
title: Creating nodes locally
weight: 4
---


# Creating nodes locally

Local nodes are used for testing and demo purposes only.

There are two ways you can create a node locally:
* __Manually__: create a local directory, add the relevant node and CorDapp files, and configure them.
* __Automatically__: use the __Cordform__ or __Dockerform__ gradle plugins, which automatically generate and configure a local set of nodes.

## Create a local node manually

To create a local node manually, make a new directory and add the following files and sub-directories:

* The Corda `.jar` artifact file, downloaded from [https://r3.bintray.com/corda/net/corda/corda/](https://r3.bintray.com/corda/net/corda/corda/) - under `../4.5/corda-4.5.jar`.
* A node configuration file with a name `node.conf`, configured as described in the [Node configuration](../setup/corda-configuration-file.md) section.
* A sub-directory with a name `cordapps`, containing any CorDapp JARs you want the node to load.
* An up-to-date version of the `network-parameters` file (see [The network map](../network-map.html#network-parameters)), generated by the bootstrapper tool.
* Optionally, a webserver JAR with a name `corda-webserver-4.5.jar`, which will connect to the node via RPC. Some alternatives to this are listed below:

    * You can use the default webserver **for testing**. Note that this feature is deprecated - do not use it in a production environment.
    * See [https://github.com/corda/spring-webserver](https://github.com/corda/spring-webserver) for a Spring Boot alternative.

The remaining node files and directories will be generated at runtime. These are described in the [Node folder structure](../setup/corda-configuration-file.md) section.

## Use the Cordform and Dockerform gradle plugins to automatically create a set of local nodes

Corda provides two `gradle` plugins called `Cordform` and `Dockerform`. They both allow you to run tasks that automatically generate and configure a local set of nodes for testing and demos.

* A `Cordform` task creates three nodes in the `build/nodes` directory: `Notary`, `PartyA`, and `PartyB`. `Cordform` tasks require you to manually deploy each Corda node and database separately.
* A `Dockerform` task is similar to `Cordform` but it provides an extra file that enables you to easily spin up nodes using `docker-compose`. This creates a `docker-compose` file that enables you to run a single command to control the deployment of Corda nodes and databases (instead of deploying each node/database manually).

{{< note >}}
Unlike `Cordform` tasks, `Dockerform` tasks require Docker to be installed on the local host.
{{< /note >}}

### Tasks using the Cordform plugin

The following example shows a `Cordform` task called `deployNodes` that creates the three nodes as described above:

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
    directory "./build/nodes"
    node {
        name "O=Notary,L=London,C=GB"
        // The Notary will offer a validating Notary service.
        notary = [validating : true]
        p2pPort  10002
        rpcSettings {
            port 10003
            adminPort 10023
        }
        // No webport property, so no webserver will be created.
        h2Port   10004
        // Starts an internal SSH server providing a management shell on the node.
        sshdPort 2223
        // Includes the corda-finance CorDapp on our node.
        cordapps = ["$corda_release_distribution:corda-finance:$corda_release_version"]
        extraConfig = [
            // Setting the JMX reporter type.
            jmxReporterType: 'JOLOKIA',
            // Setting the H2 address.
            h2Settings: [ address: 'localhost:10030' ]
        ]
    }
    node {
        name "O=PartyA,L=London,C=GB"
        p2pPort  10005
        rpcSettings {
            port 10006
            adminPort 10026
        }
        webPort  10007
        h2Port   10008
        cordapps = ["$corda_release_distribution:corda-finance:$corda_release_version"]
        // Grants user1 all RPC permissions.
        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
    }
    node {
        name "O=PartyB,L=New York,C=US"
        p2pPort  10009
        rpcSettings {
            port 10010
            adminPort 10030
        }
        webPort  10011
        h2Port   10012
        cordapps = ["$corda_release_distribution:corda-finance:$corda_release_version"]
        // Grants user1 the ability to start the MyFlow flow.
        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["StartFlow.net.corda.flows.MyFlow"]]]
    }
}
```

Run this task to create the following three nodes in the `build/nodes` directory:

A `Notary` node, which:
* Provides a validating Notary service.
* Does not have a webserver - `webPort` is not defined.
* Runs the `corda-finance` CorDapp.

`PartyA` and `PartyB` nodes, each of which:
* Does not provide any services.
* Has a webserver - `webPort` is defined.
* Runs the `corda-finance` CorDapp.
* Has an RPC (Remote Procedure Call) user (`user1`), which enables you to log in the node via RPC.

All three nodes also include any CorDapps defined in the project's source directories, even if these CorDapps are not listed in each node's `cordapps` setting. As a result, if you run the `deployNodes` task from the template CorDapp, for example, it will automatically build and add the template CorDapp to each node.

The configuration values used in the `deployNodes` task example are described below.

#### Required configuration

* `name` &lt;string&gt; - the legal identity name of the Corda node (see [myLegalName](../setup/corda-configuration-file.md#corda-configuration-file-mylegalname)). For example:

```kotlin
name "O=PartyA,L=London,C=GB"
```
* `p2pAddress` &lt;string&gt; - the address/port the node uses for inbound communication from other nodes (see [p2pAddress](../setup/corda-configuration-file.md#corda-configuration-file-p2paddress)). **Required if `p2pPort` not specified**. For example:

```kotlin
p2pAddress "example.com:10002"
```
* `p2pPort` &lt;integer&gt; - the port the node uses for inbound communication from other nodes.  Assumes the address is `localhost` (see [p2pAddress](../setup/corda-configuration-file.md#corda-configuration-file-p2paddress)). For example:

```kotlin
p2pPort 10006  // "localhost:10006"
```

* `rpcSettings` &lt;config&gt; - specifies RPC settings for the node (see [rpcSettings](../setup/corda-configuration-file.md#corda-configuration-file-rpc-settings)). For example:

```kotlin
rpcSettings {
  port 10006
  adminPort 10026
}
```

#### Optional configuration

* `notary` &lt;config&gt; - optional configuration, which specifies the node is a Notary (see [Notary](../setup/corda-configuration-file.md#corda-configuration-file-notary)). **Required**> for Notary nodes.

* `devMode` &lt;boolean&gt; - enables development mode when set to `true` (see [devMode](../setup/corda-configuration-file.md#corda-configuration-file-dev-mode))
    * e.g.

```kotlin
devMode true
```




* `webAddress` <string>
    * Configure a webserver to connect to the node via RPC. This will specify the address and port it will listen on. The node must have an RPC address configured. (see [Specifying a custom webserver](#specify-custom-webserver))
    * e.g.

```kotlin
webAddress  "example.com:10011"
```




* `webPort` <integer>
    * Configure a webserver to connect to the node via RPC. Defaults the address to *localhost*. The node must have an RPC address configured. (see [Specifying a custom webserver](#specify-custom-webserver))
    * e.g.

```kotlin
webPort  10011  // "localhost:10011"
```




* `rpcUsers` <list>
    * Set the RPC users for this node. (see [rpcUsers](../setup/corda-configuration-file.md#corda-configuration-file-rpc-users))
    * e.g.

```kotlin
rpcUsers = [[ user: "user1", "password": "test", "permissions": ["StartFlow.net.corda.flows.MyFlow"]]]
```


    * This configuration block allows arbitrary configuration. Incorrect configurations will not cause a DSL error.


* `configFile` <string>
    * For extending configuration of nodes. (see [extended node configuration](#generating-a-node-extended-config))
    * e.g.

```kotlin
configFile = "samples/trader-demo/src/main/resources/node-b.conf"
```


* `https` <boolean>
    * When true enables HTTPS communication from the node webserver.
    * e.g.

```kotlin
https true
```


* `sshdPort` <integer>
    * Specifies the port for sshd communication. (see [sshd](../setup/corda-configuration-file.md#corda-configuration-file-sshd))
    * e.g.

```kotlin
sshd {
  port = 2222
}
```

You can extend the task `deployNodes` with more `node {}` blocks to generate as many nodes as necessary for your application.


{{< warning >}}
When adding nodes, make sure that there are no port clashes!

{{< /warning >}}



To extend node configuration beyond the properties defined in the `deployNodes` task use the `configFile` property with the path (relative or absolute) set to an additional configuration file.
This file should follow the standard corda-configuration-file format, as per node.conf. The properties from this file will be appended to the generated node configuration.

{{< note >}}
If you add a property already created by the ‘deployNodes’ task, both properties will be present in the file.
{{< /note >}}

The path to the file can also be added while running the Gradle task via the `-PconfigFile` command line option. However, the same file will be applied to all nodes.

Following the previous example `PartyB` node will have additional configuration options added from a file `none-b.conf`:

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
    [...]
    node {
        name "O=PartyB,L=New York,C=US"
        [...]
        // Grants user1 the ability to start the MyFlow flow.
        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["StartFlow.net.corda.flows.MyFlow"]]]
        configFile = "samples/trader-demo/src/main/resources/node-b.conf"
    }
}
```

Cordform parameter *drivers* of the *node* entry lists paths of the files to be copied to the *./drivers* subdirectory of the node.
To copy the same file to all nodes *ext.drivers* can be defined in the top level and reused for each node via *drivers=ext.drivers`*.

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
    ext.drivers = ['lib/my_common_jar.jar']
    [...]
    node {
        name "O=PartyB,L=New York,C=US"
        [...]
        drivers = ext.drivers + ['lib/my_specific_jar.jar']
    }
}
```

The Cordform task will automatically copy a Jolokia agent JAR into each generated node’s *drivers* subdirectory. The version of this JAR
defaults to *1.6.0*. This can be changed by setting the *jolokia_version* property anywhere in your *build.gradle* file:

```groovy
ext.jolokia_version = "1.6.1"
```



#### Package namespace ownership

To specify [Package namespace ownership](env-dev.md#package-namespace-ownership) configuration, the optional `networkParameterOverrides` and `packageOwnership` blocks can be used, similar to the configuration file used in network-bootstrapper:

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
    [...]
    networkParameterOverrides {
        packageOwnership {
            "com.mypackagename" {
                keystore = "_teststore"
                keystorePassword = "MyStorePassword"
                keystoreAlias = "MyKeyAlias"
            }
        }
    }
    [...]
}
```


#### Sign CorDapp JARs

The default behaviour of Cordform is to deploy CorDapp JARs “as built”:



* prior to Corda 4 all CorDapp JARs were unsigned.
* as of Corda 4, CorDapp JARs created by the Gradle *cordapp* plugin are signed by a Corda development certificate by default.


The Cordform `signing` entry can be used to override and customise the signing of CorDapp JARs.
Signing the CorDapp enables its contract classes to use signature constraints instead of other types of the constraints api-contract-constraints.

The sign task may use an external keystore, or create a new one.
The `signing` entry may contain the following parameters:


* `enabled` the control flag to enable signing process, by default is set to `false`, set to `true` to enable signing
* `all` if set to `true` (by default) all CorDapps inside *cordapp* subdirectory will be signed, otherwise if `false` then only the generated Cordapp will be signed
* `options` any relevant parameters of [SignJar ANT task](https://ant.apache.org/manual/Tasks/signjar.html) and [GenKey ANT task](https://ant.apache.org/manual/Tasks/genkey.html),
by default the JAR file is signed by Corda development key, the external keystore can be specified,
the minimal list of required options is shown below, for other options referer to [SignJar task](https://ant.apache.org/manual/Tasks/signjar.html):
    * `keystore` the path to the keystore file, by default *cordadevcakeys.jks* keystore is shipped with the plugin
    * `alias` the alias to sign under, the default value is *cordaintermediateca*
    * `storepass` the keystore password, the default value is *cordacadevpass*
    * `keypass` the private key password if it’s different than the password for the keystore, the default value is *cordacadevkeypass*
    * `storetype` the keystore type, the default value is *JKS*
    * `dname` the distinguished name for entity, the option is used when `generateKeystore true` only
    * `keyalg` the method to use when generating name-value pair, the value defaults to *RSA* as Corda doesn’t support *DSA*, the option is used when `generateKeystore true` only


* `generateKeystore` the flag to generate a keystore, it is set to `false` by default. If set to `true` then ad hock keystore is created and its key isused
instead of the default Corda development key or any external key.
The same `options` to specify an external keystore are used to define the newly created keystore. Additionally
`dname` and `keyalg` are required. Other options are described in [GenKey task](https://ant.apache.org/manual/Tasks/genkey.html).
If the existing keystore is already present the task will reuse it, however if the file is inside the *build* directory,
then it will be deleted when Gradle *clean* task is run.

The example below shows the minimal set of `options` needed to create a dummy keystore:

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
     signing {
        enabled true
        generateKeystore true
        all false
        options {
            keystore "./build/nodes/jarSignKeystore.p12"
            alias "cordapp-signer"
            storepass "secret1!"
            storetype "PKCS12"
            dname "OU=Dummy Cordapp Distributor, O=Corda, L=London, C=GB"
            keyalg "RSA"
        }
    }
    //...
```

Contracts classes from signed CorDapp JARs will be checked by signature constraints by default.
You can force them to be checked by zone constraints by adding contract class names to `includeWhitelist` entry,
the list will generate *include_whitelist.txt* file used internally by network-bootstrapper tool.
Refer to api-contract-constraints to understand implication of different constraint types before adding `includeWhitelist` to `deployNodes` task.
The snippet below configures contracts classes from Finance CorDapp to be verified using zone constraints instead of signature constraints:

```groovy
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {
    includeWhitelist = [ "net.corda.finance.contracts.asset.Cash", "net.corda.finance.contracts.asset.CommercialPaper" ]
    //...
```



#### Specify a custom webserver

By default, any node listing a web port will use the default development webserver, which is not production-ready. You
can use your own webserver JAR instead by using the `webserverJar` argument in a `Cordform` `node` configuration
block:

```groovy
node {
    name "O=PartyA,L=New York,C=US"
    webPort 10005
    webserverJar "lib/my_webserver.jar"
}
```

The webserver JAR will be copied into the node’s `build` directory with the name `corda-webserver.jar`.


{{< warning >}}
This is an experimental feature. There is currently no support for reading the webserver’s port from the
node’s `node.conf` file.

{{< /warning >}}


#### Run the Cordform task

To create the nodes defined in our `deployNodes` task, run the following command in a terminal window from the root of the project where the `deployNodes` task is defined:

* Linux/macOS: `./gradlew deployNodes`
* Windows: `gradlew.bat deployNodes`

This will create the nodes in the `build/nodes` directory. There will be a node directory generated for each node defined in the `deployNodes` task, plus a `runnodes` shell script (or batch file on Windows) to run all the nodes at once
for testing and development purposes. If you make any changes to your CorDapp source or `deployNodes` task, you will need to re-run the task to see the changes take effect.


### The Dockerform task


Dockerform supports the following configuration options for each node:


* `name`
* `notary`
* `cordapps`
* `rpcUsers`
* `useTestClock`

There is no need to specify the nodes' ports, as every node has a separate container, so no ports conflict will occur. Every node will expose port `10003` for RPC connections.

The nodes' webservers will not be started. Instead, you should interact with each node via its shell over SSH (see the node configuration options). You have to enable the shell by adding the following line to each node’s `node.conf` file:


`sshd { port = <NUMBER> }`


Where `<NUMBER>` is the port you want to open to SSH into the shell.


The Docker image associated with each node can be configured in the `Dockerform` task. This will initialise *each* node in the `Dockerform` task with the specified Docker image. If you need nodes with different Docker images, you can edit the `docker-compose.yml` file with your preferred image.

To run the Dockerform task, follow these steps:

* Open the `build.gradle` file of your Cordapp project and add a new gradle task:
```groovy
task prepareDockerNodes(type: net.corda.plugins.Dockerform, dependsOn: ['jar']) {
    nodeDefaults {
        cordapp project(":contracts-java")
    }
    node {
        name "O=Notary,L=London,C=GB"
        notary = [validating : false]
        p2pPort 10002
        rpcSettings {
            address("localhost:10003")
            adminAddress("localhost:10023")
        }
        projectCordapp {
            deploy = false
        }
        cordapps.clear()
    }
    node {
        name "O=PartyA,L=London,C=GB"
        p2pPort 10002
        rpcSettings {
            address("localhost:10003")
            adminAddress("localhost:10023")
        }
        rpcUsers = [[user: "user1", "password": "test", "permissions": ["ALL"]]]
    }
    node {
        name "O=PartyB,L=New York,C=US"
        p2pPort 10002
        rpcSettings {
            address("localhost:10003")
            adminAddress("localhost:10023")
        }
        rpcUsers = [[user: "user1", "password": "test", "permissions": ["ALL"]]]
    }

    // This property needs to be outside the node {...} elements
    dockerImage = "corda/corda-zulu-java1.8-4.4"
}
```

* Run `./gradlew prepareDockerNodes` to generate the `build` directory. This folder contains the node files and a `docker-compose.yml` file.
* Edit the generated `docker-compose.yml` file to change the ports:
```groovy
version: '3'
services:
  notary:
    build: /Users/<USER>/Projects/json-cordapp/workflows-java/build/nodes/Notary
    ports:
      - "10002"
      - "10003"
  partya:
    build: /Users/<USER>/Projects/json-cordapp/workflows-java/build/nodes/PartyA
    ports:
      - "10002"
      - "10003"
  partyb:
    build: /Users/<USER>/Projects/json-cordapp/workflows-java/build/nodes/PartyB
    ports:
      - "10002"
      - "10003"
```


#### Specify an external database

You can configure `Dockerform` to use a standalone database to test with non-H2 databases. For example, to use PostgresSQL, you need to make the following changes to your Cordapp project:

* Create a file called `postgres.gradle` in your Cordapp directory and insert the following code block:

```groovy
ext {
    postgresql_version     = '42.2.12'
    postgres_image_version = '11'
    dbUser                 = 'myuser'
    dbPassword             = 'mypassword'
    dbSchema               = 'myschema'
    dbName                 = 'mydb'
    dbPort                 = 5432
    dbHostName             = 'localhost'
    dbDockerfile           = 'Postgres_Dockerfile'
    dbInit                 = 'Postgres_init.sh'
    dbDataVolume           =  [
            hostPath      : 'data',
            containerPath : '/var/lib/postgresql/data:\${SUFFIX}',
            containerPathArgs   : [
                    SUFFIX : "rw"
            ]
    ]
    postgres = [
            dataSourceProperties: [
                    dataSourceClassName: 'org.postgresql.ds.PGSimpleDataSource',
                    dataSource: [
                            user    : dbUser,
                            password: dbPassword,
                            url     : "jdbc:postgresql://\${DBHOSTNAME}:\${DBPORT}/\${DBNAME}?currentSchema=\${DBSCHEMA}",
                            urlArgs : [
                                    DBHOSTNAME  : dbHostName,
                                    DBPORT      : dbPort,
                                    DBNAME      : dbName,
                                    DBSCHEMA    : dbSchema
                            ]
                    ]
            ],
            database: [
                    transactionIsolationLevel: 'READ_COMMITTED',
                    runMigration             : true,
                    schema                   : dbSchema
            ],
            dockerConfig: [
                    dbDockerfile    : dbDockerfile,
                    dbDockerfileArgs: [
                         DBNAME         : dbName,
                         DBSCHEMA       : dbSchema,
                         DBUSER         : dbUser,
                         DBPASSWORD     : dbPassword,
                         DBPORT         : dbPort
                    ],
                    dbUser          : dbUser,
                    dbPassword      : dbPassword,
                    dbSchema        : dbSchema,
                    dbName          : dbName,
                    dbPort          : dbPort,
                    dbHostName      : dbHostName,
                    dbDatabase      : dbName,
                    dbDataVolume    : dbDataVolume
            ]
    ]
}

apply plugin: 'net.corda.plugins.cordformation'

dependencies {
    cordaDriver "org.postgresql:postgresql:$postgresql_version"
}

def generateInitScripts = tasks.register('generateInitScripts') { Task task ->
    def initialDockerfile = file("$buildDir/$dbDockerfile")
    def initialScript = file( "$buildDir/$dbInit")
    task.inputs.properties(project['postgres'])
    task.outputs.files(initialDockerfile, initialScript)
    /*
     * Dockerfile to initialise the PostgreSQL database.
     */
    task.doLast {
        initialDockerfile.withPrintWriter('UTF-8') { writer ->
            writer << """\
# Derive from postgres image
FROM postgres:$postgres_image_version

ARG DBNAME=$dbName
ARG DBSCHEMA=$dbSchema
ARG DBUSER=$dbUser
ARG DBPASSWORD=$dbPassword
ARG DBPORT=$dbPort

ENV POSTGRES_DB=\$DBNAME
ENV POSTGRES_DB_SCHEMA=\$DBSCHEMA
ENV POSTGRES_USER=\$DBUSER
ENV POSTGRES_PASSWORD=\$DBPASSWORD
ENV PGPORT=\$DBPORT

# Copy all postgres init file to the docker entrypoint
COPY ./$dbInit /docker-entrypoint-initdb.d/$dbInit

# Allow postgres user to run init script
RUN chmod 0755 /docker-entrypoint-initdb.d/$dbInit
"""
        }

        /**
         * Append the persistence configuration if persistence is required (i.e., persistence=true)
         */
        if (project.hasProperty("dbDataVolume")) {

            initialDockerfile.withWriterAppend('UTF-8') { writer ->
                writer << """\

# Associate the volume with the host user
USER 1000:1000

# Initialise environment variable with database directory
ENV PGDATA=/var/lib/postgresql/data/pgdata
"""
            }
        }

        /*
         * A UNIX script to generate the init.sql file that
         * PostgreSQL needs. This must use UNIX line endings,
         * even when generated on Windows.
         */
        initialScript.withPrintWriter('UTF-8') { writer ->
            writer << """\
#!/usr/bin/env bash
# Postgres database initialisation script when using Docker images

dbUser=\${POSTGRES_USER:-"$dbUser"}
dbPassword=\${POSTGRES_PASSWORD:-"$dbPassword"}
dbSchema=\${POSTGRES_DB_SCHEMA:-"$dbSchema"}
dbName=\${POSTGRES_DB:-"$dbName"}

psql -v ON_ERROR_STOP=1 --username "\$dbUser"  --dbname "\$dbName" <<-EOSQL
        CREATE SCHEMA \$dbSchema;
        GRANT USAGE, CREATE ON SCHEMA \$dbSchema TO \$dbUser;
        GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON ALL tables IN SCHEMA \$dbSchema TO \$dbUser;
        ALTER DEFAULT privileges IN SCHEMA \$dbSchema GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON tables TO \$dbUser;
        GRANT USAGE, SELECT ON ALL sequences IN SCHEMA \$dbSchema TO \$dbUser;
        ALTER DEFAULT privileges IN SCHEMA \$dbSchema GRANT USAGE, SELECT ON sequences TO \$dbUser;
        ALTER ROLE \$dbUser SET search_path = \$dbSchema;
EOSQL
""".replaceAll("\r\n", "\n")
        }
        initialScript.executable = true
    }
}
```

In the `build.gradle` file:
* Add the gradle task `generateInitScripts` to `dependsOn` list of `prepareDockerNodes` task;
* Add the `dockerConfig` element and initialise it with `postgres` block as follows:

```groovy
task prepareDockerNodes(type: net.corda.plugins.Dockerform, dependsOn: ['jar',  'generateInitScripts']) {

    [...]

    node {
        [...]
    }

    // The postgres block from the postgres.gradle file
    dockerConfig = postgres
}
```

The `postgres.gradle` file includes:
* A gradle task `generateInitScripts` to generate the Postgres Docker image files;
* A set of variables to initialise the Postgres Docker image.

Two files are necessary to setup the external database, which are placed in the `build` directory:
* `Postgres_Dockerfile` :  a wrapper for the base Postgres Docker image;
* `Postgres_init.sh` :  a shell script to initialise the database.

The `Postgres_Dockerfile` is referenced in the `docker-compose.yml` file, and allows for a number of arguments to configure the Docker image.

The following parameters can be configured in the `postgres.gradle` file:

| Parameter              | Description                                       |
|------------------------|---------------------------------------------------|
| postgresql_version     | Version of JDBC driver to connect to the database |
| postgres_image_version | Version of Postgres Docker image                  |
| dbUser                 | Database user                                     |
| dbPassword             | Database password                                 |
| dbSchema               | Postgres schema                                   |
| dbName                 | Database name                                     |
| dbPort                 | Database port (default: 5432)                     |
| dbHostName             | Database host (default: localhost)                |
| dbInit                 | Initialisation script for Postgres Docker image   |
| dbDockerfile           | Wrapper of base Postgres Docker image             |
| dbDataVolume           | Path to database files for Postgres Docker image  |


To make the database files can be made persistent across multiple `Dockerform` runs, you need to set the parameter `dbDataVolume`. If this variable is commented out, the database files will be removed after every Dockerform run.

#### Run the Dockerform task

To create the nodes defined in our `prepareDockerNodes` gradle task, run the following command in a terminal window from the root of the project where the `prepareDockerNodes` task is defined:

* Linux/macOS: `./gradlew prepareDockerNodes`
* Windows: `gradlew.bat prepareDockerNodes`

This will create the nodes in the `build/nodes` directory. There will be a node directory generated for each node defined in the `prepareDockerNodes` task. The task will also create a `docker-compose.yml` file in the `build/nodes` directory.

If you configure an external database as detailed above, a `Postgres_Dockerfile` file and `Postgres_init.sh` file will be generated in the `build` directory. If you make any changes to your CorDapp source or `prepareDockerNodes` task, you will need to re-run the task to see the changes take effect.

Each Corda node will be associated with a Postgres database. There will not be two or more Corda nodes connecting to the same database. While there is no maximum number of nodes you can deploy with `Dockerform`, you are constrained by the maximum available resources on the machine running this task as well as the overhead introduced by each started Docker container. All the started nodes run in the same Docker overlay network.

The connection settings to the Postgres database are provided to each node through the `postgres.gradle` file. The Postgres JDBC driver is provided via Maven as part of the `cordaDrive` gradle configuration, which is also specified in the dependencies block of the `postgres.gradle` file.


{{< note >}}
We have not designed this feature for users to access the database via elevated or admin rights - you must only use such configuration changes for testing/development purposes.
{{< /note >}}
